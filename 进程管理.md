

[toc]

# 操作系统——进程

## 1.1 进程组成

>- 程序：
>
>  - 一个指令序列，早期计算机只支持单道程序
>  - 程序段+数据段+PCB
>    - 程序段：存放程序的代码
>    - 数据段：
>    - PCB：进程控制块，包含操作系统对进程管理的相关信息
>      - 进程描述信息：进程标识符pid、用户标识符uid
>      - 进程控制和管理信息：进程当前状态、进程优先级
>      - 资源分配清单：程序段指针、数据段指针、键盘、鼠标
>      - 处理机相关信息：各种寄存器的值
>
>- 进程的组织方式：
>
>  - 连接方式
>
>    - 按照进程状态将pcb分为多个队列
>
>    - 操作系统持有指向各个队列的指针
>
>      > 执行指针 -> 指向当前处于执行态的进程
>      >
>      > 就绪队列指针-> 指向当前就绪态的进程
>      >
>      > 阻塞队列指针-> 指向当前阻塞态的进程
>
>  - 索引方式
>
>    - 根据进程状态的不同，建立几张索引表
>
>    - 操作系统持有指向各个索引的指针
>
>      > 执行指针、就绪表指针、阻塞表指针



## 1.2 进程的状态与转换

**状态**

1. 运行态
2. 就绪态
3. 阻塞态
4. 创建态终止态

**状态转换**

1. 就绪态->运行态：被调度
2. 运行态->就绪态：时间片到了，或cpu被其他高优先级的进程抢占了
3. 运行态->阻塞态：等待系统分配资源，或者等待某件事情发生
4. 阻塞态->就绪态：资源分配到位，等待的时间发生

## 1.3 进程控制

>-  基本概念
>   -  进程控制就是要实现进程状态的转换
>   -  进程控制用原语实现
>      -  原语用开/关中断实现
>      -  原语是一种特殊的程序
>      -  原语的执行必须一气呵成，**不可中断**
>-  相关原语

## 1.4 进程间通信

> - 共享存储
>   - 设置一个共享空间
>   - 互斥地访问共享空间
>   - 两种方式
>     - 基于数据结构
>     - 基于存储区的共享
> - 管道通信
>   - 设置一个特殊的共享文件(管道)，其实就是一个缓冲区
>   - 一个管道智能实现半双工通信
>   - 实现双向同时通信需要建立两个管道
>   - 个进程要互斥地访问管道
>   - **写满时，不能再写，读空时，不能再读**
>   - **没写满，不能读，没读空，不能写**
> - 消息传递
>   - 传递结构化的消息(消息头/消息体)
>   - 系统提供“发送/接收原语”
>   - 两种方式
>     - 直接通信：消息直接挂到接收方的消息队列里
>     - 间接通信：消息先发到信箱

## 1.5 线程、多线程模型

> - 什么是线程、为什么要引入线程
>   - 轻量级进程
>   - 可以增加并发度、减少并发带来的开销
> - 引入线程及之后，有什么变化
>   - 资源分配、处理机调度
>   - 并发性
>   - 实现并发的系统开销
> - 线程重要属性
>   - 线程是处理机调度的单位，进程是资源分配的单位
>   - 同一个进程的各线程共享进程拥有的资源
>   - 统一进程内的线程切换不会导致进程的切换
> - 线程的实现方式
>   - 用户级线程：从用户角度看的线程
>   - 内核级线程：
>   - 组合方式

---

## 1.6 处理机调度

> - 基本概念：按某种算法选择一个进程将处理机分配给它
> - 三个层次
>   - 高级调度(作业调度)：从后背队列中选择合适的作业，将其调入内存，并为其创建进程
>   - 中级调度(内存调度)：从挂起队列中选择合适的进程，将其数据调回内存
>   - 低级调度(进程调度)：从就绪队列中选择一个进程，为期分配处理机
> - 三个调度的联系、对比
>   - 高级调度：
>     - 外存->内存(面向作业)
>     - 发生频率：低
>   - 中级调度：
>     - 外存->内存(面向挂起进程)
>     - 发生频率：中
>   - 低级调度：
>     - 外存->cpu
>     - 发生频率：高
> - 补充：
>   - 为了减轻系统负载，提高资源利用率，暂时不执行的进程，会被调到外存，从而变成**挂起态**
>   - 在五状态模型中，加入了，**就绪挂起**和**阻塞挂起**两种状态，称为了七状态模型

1. #### 调度算法的评价指标

   - cpu利用率
     - 指cpu处于忙碌时间，占用总时间的比例
   - 系统吞吐量
     - 单位时间内，完成作业的数量
   - 周转时间
     - 作业提交给系统开始，作业完成为止，的时间间隔
     - 平均周转时间=总的周转时间/进程个数
   - 等待时间
     - 进程/作业处于等待处理机状态时间之和
   - 响应时间
     - 用户从提出请求，到首次产生相应的时间

2. #### 调度算法

   > - FCFS 先来先服务
   > - SJF短作业优先
   > - HRNN 高响应比优先
   >
   > 
   >
   > - RR 时间片轮转
   > - 优先级调度算法
   > - 多级反馈队列调度算法

   - **FCFS**

     > 按照到达的先后顺序调度，相当于等待时间越久的越优先得到服务
     >
     > 对长作业友好

     - 算法思想：主要从公平的角度考虑
     - 算法规则：按照到达的先后顺序进行服务
     - 非抢占式
     - 不会导致饥饿
     - 优点：公平、简单
     - 缺点：排在长作业后面的短作业需要等待很长时间，对长作业有利，对短作业不利

   - **SJF**

     > 服务时间最短的作业/进程优先得到服务，追求最少的平均等待时间，最少的平均周转时间
     >
     > 对短作业友好

     - 作业调度SJF 、进程调度SPF、都是非抢占式算法，最短剩余时间SRTN是抢占式
     - 非抢占式，最短剩余时间是抢占式
     - 可能会导致饥饿
     - 优点：最短的平均等待时间、平均周转时间，
     - 缺点：不公平，对短作业有利，长作业不利，且运行时间是由用户提供的，不一定真实，不一定能够做到短作业优先

   - **HRNN**

     > 先计算响应比，选择响应比最高的进程/作业为其服务，要综合考虑作业/进程的等待时间和要求服务的时间
     >
     > 响应比=(等待时间+要求服务时间)/要求服务时间    >=1

     - 非抢占式
     - 不会导致饥饿
     - 优点：
       - 综合考虑了**等待时间**和**运行时间**(要求服务时间)
       - 等待时间相同时，要求服务时间短的优先(SJF优点)
       - 要求服务时间相同时，等待时间长的优先(FCFS优点)
       - 对长作业来说，随着等待时间越来越久，其响应比也回越来越大，从而避免了长作业饥饿的问题

   - **RR 时间片轮转**

     > - 公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到相应
     >
     > - 按照各个进程到达就绪队列的顺序，轮流让各个进程执行一个时间片(eg.100ms)，若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队

     - 抢占式，通过时钟中断来抢占处理机
     - 如果时间片过大，RR会退化为FCFS
     - 如果时间片过小，进程切换频繁，系统开销过大
     - 设计时间片时，让切换进程的开销比，不超过1%
     - 优点：公平、响应快、适用于分时操作系统
     - 缺点：高频率的进程切换，有一定开销，不区分任务的紧急程度

   - 优先级调度算法

     > 每个作业/进程有自己的优先级，调度时，选择优先级最高的作业/进程
     >
     > 能够根据任务的紧急程度来进行处理

     - 抢占式、非抢占式都有
       - 非抢占式只需要在进程主动放弃处理机时调度即可
       - 抢占式需要在就绪队列变化时，检查是否会发生抢占
     - 优先级设定
       - 系统进程 > 用户进程
       - 前台进程 > 后台进程
       - 操作系统更偏好I/O型进程
       - 动态调整优先级
         - eg,等待时间过长，可适当提高其优先级
     - 优点：
       - 可以区分紧急程度、重要程度
       - 可以灵活地调整对各种作业/进程的偏好程度
     - 缺点：
       - 若源源不断的高优先级进程到来，可能会导致饥饿

   - **多级反馈队列调度算法**

     > 对其他调度算法的折中权衡
     >
     > - 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大
     > - 新进程到达时，先进入第一级队列，按照FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进入下一级队列的队尾，如果此时已经在最下级的队列，则放到该队列的队尾
     > - 只有k级队列为空时，才会为k+1级队头的进程分配时间片

     - 抢占式算法：
       - 在k级队列的进程运行过程中，如果更上级的队列中进入了一个新锦成，则由于进程处于优先级更高的队列中，因此新锦成会抢占处理机，原来运行的进程放回k级队列队尾
     - 优点：
       - 对各类型进程相对公平(FCFS优点)
       - 每个新到达的进程都可以很快得到相应(RR优点)
       - 短进程只用较少的时间就可以完成(SPF优点)
       - 不必实现估计进程的运行时间(避免用户作假)
       - 可灵活地调整对各类进程的偏好程度，如CPU密集型，IO密集型
     - 缺点：
       - 有可能会导致饥饿

   ---

   

   ## 1.7 进程同步、互斥

   > 进程异步：各并发进程的进程以格子独立的，不可预知的速度向前推进
   >
   > 进程同步：直接制约关系，多个进程需要在某些位置上 **协调** 他们的 **工作次序** 而产生的制约关系
   >
   > 进程互斥：当一个进程访问某临界资源时，另一个想要访问该资源的进程必须等待，直到上一个进程释放掉该资源后，才可以访

   - 进程互斥的软件实现方法
     - 单标志法

       > `int turn = 0;//turn表示当前允许进入临界区的进程号`
       >
       > ```c++
       > //p0进程
       > while(turn != 0);
       > do something;//进入临界区
       > turn = 1;//退出临界区
       > ```
       >
       > ```c++
       > //p1进程
       > while(turn != 1);
       > do something; //进入临界区
       > turn = 0;//退出临界区
       > ```
       >
       > 同一时刻只允许一个进程访问临界区
       >
       > **违反了空闲让进的原则**
       >
       > 阻塞在：==自己是否能用临界区==
       >
       > 

     - 双标志先检查

       > `bool flag[2];` 表示进入临界区意愿的数组
       >
       > `flag[0] = false;  flag[1] = false;` 刚开始设定两个进程都不想进入临界区
       >
       > ```c++
       > //p0进程
       > while(flag[1]);
       > flag[0] = true;
       > do something;
       > flag[0] = false;
       > ```
       >
       > ```c++
       > //p1进程
       > while(flag[0]);
       > flag[1] = true;
       > do something;
       > flag[1] = false;
       > ```
       >
       > 先检查，后上锁
       >
       > 阻塞在：==对方是否在用临界区==
       >
       > 并发情况下，有可能两个进程同时进入临界区，因为检查和上锁并未一气呵成

     - 双标志后检查

       > `bool flag[2];` 表示进入临界区意愿的数组
       >
       > `flag[0] = false;   flag[1]=false;` 刚开始设定两个进程都不想进入临界区
       >
       > ```c++
       > //p0进程
       > flag[0] = true;
       > while(flag[1]);
       > do something;
       > flag[0] = false;
       > ```
       >
       > ```c++
       > //p1进程
       > flag[1] = true;
       > while(flag[0]);
       > do something;
       > flag[1] = false;
       > ```
       >
       > 先上锁，后检查
       >
       > 容易产生饥饿现象

     - Peterson算法

       > 结合 `单标志法` 和 `双标志法`
       >
       > ```c++
       > bool flag[2];	//表示进入临界区意愿的数组
       > int turn = 0;	//turn表示优先让那个进程进入临界区
       > //p0进程
       > flag[0] = true;		//我想获取临界资源
       > turn = 1;					//你先来
       > while(flag[1] && turn == 1);	//你想获获取临界资源 且 轮到你了，我就等
       > do something;	//你不想获取，或者还没轮到你，那我就先做事情了
       > flag[0] = false;	//我做完了，不想获取临界资源了
       > 
       > //p1进程
       > flag[1] = true;
       > turn = 0;
       > while(flag[0] && turn == 0);
       > do something;
       > flag[1] = false;
       > ```
       >
       > - 可以实现：
       >   - 空闲让进
       >   - 忙则等待
       >   - 有限等待
       > - 未实现：
       >   - 让权等待：等待的时候，仍然占用CPU，因为使用while阻塞的

   - 进程互斥的硬件实现方法

     - 中断屏蔽方法

       > 利用==开/关中断==实现，先执行关中断，则进程无法被中断，直至运行到开中断
       >
       > - 优点：简单
       > - 缺点：==不适用于多处理机==

     - TestAndSetLock(TS指令/TSL指令)  -> 传说中的==**自旋锁**==

       >  ```c++
       > //检查并上锁，一气呵成，返回的是原始状态，是用硬件实现的
       > bool TestAndSetLock(bool *lock) {
       >   bool old = *lock;
       >   *lock = true;
       >   return old;
       > }
       > 
       > //p0
       > while(TestAndSetLock(&lock));		//检查是否上锁，如果上锁了，就一直等
       > do something;
       > lock = false;			//解锁，这里解锁了，其他线程就可以走出while了
       >  ```
       >
       > - 优点：实现简单，适用于多处理机环境
       > - 缺点：不满足`让权等待原则`，等待过程中仍然会占用CPU

     - Swap指令(XCHG指令)

       > 逻辑上与TSL相同
       >
       > ```c++
       > bool old=true;
       > while(old == true) {
       >   Swap(&lock,&old);	//这里不断地把lock的值 交换给old，直至有人修改了lock为false
       > }
       > do something;
       > lock=false;	//解锁，其他线程便可以走出while了
       > ```

![](https://img-blog.csdn.net/20171121130628916)

- 死锁产生条件

  - 互斥条件
  - 不剥夺条件
  - 请求和保持条件
  - 循环等待条件

  

- 避免死锁策略

  - 破坏互斥条件

    > 把互斥设备改造为共享设备
    >
    > ==SPOOLing技术==：使用一个输出进程来统一管理获取该设备的所有进程，在各个进程看来，该设备就是共享的
    >
    > - 缺点：并不是所有资源都可以被打造成共享资源，且为了安全性，很多地方必须保持互斥性

  - 破坏不剥夺条件

    > - 当某个进程请求新的资源得不到满足的时候，必须立即释放掉其保持的所有资源，待以后需要时，再重新申请
    >
    >   > 也就是说，及时某些资源尚未用完，也需要主动释放，从而破坏不可剥夺条件
    >
    >   
    >
    > - 当某个进程需要的资源被其他进程占有的时候，可以由操作系统协助，强行剥夺给优先级更高的进程使用
    >
    > 缺点：
    >
    > 		- 实现复杂	
    > 		- 释放已获得的资源需要保存状态。
    > 		- 反复申请和释放，会增大系统开销，降低系统吞吐量

  - 破坏请求和保持条件

    > 可以采用==静态分配==的方法
    >
    > 	> 在进程运行前，一次申请完所需全部资源，在资源未满足前，不让其投入运行，一旦投入运行后，这些资源一直归他所有，不会再请求任何其他资源
    >
    > 缺点：会导致资源利用率低

  - 破坏循环等待条件

    > 